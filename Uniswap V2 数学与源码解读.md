本篇研报是对 UniswapV2 协议的工作原理、项目构成、源码分析等部分进行详细解读。 工作原理主要是涉及自动做市商（ AMM ），本篇研报会描述流动性池的创建和管理过程，以及如何通过提供流动性赚取手续费；在项目构成方面，我们主要概述 UniswapV2 的架构，包括主要合约（如工厂合约、交换合约）及其功能；在源码分析部分我们分析 UniswapV2 的智能合约源码，解释关键函数和数据结构的设计理念。

![图片](univ2-img/640.1.webp)

UniswapV2 是一种去中心化交易协议，基于以太坊区块链，允许用户无需信任中介即可进行加密货币的交易。与传统的中心化交易所不同，UniswapV2 采用了自动做市商（ AMM ）模型，通过智能合约来管理交易和流动性池，从而实现完全的去中心化。

UniswapV2 的核心在于其恒定乘积公式（ _x \* y = k_ ），其中 _x_ 和 _y_ 分别代表流动性池中两种不同资产的数量，_k_ 是一个常数。这个公式确保了在每次交易后，池中的资产比例会重新平衡，从而为用户提供流动性。这种设计使得交易过程透明且公平，用户可以随时添加或移除流动性，并通过交易手续费赚取收益。

UniswapV2 协议由多个智能合约构成，其中最主要的是工厂合约和交换合约。工厂合约负责创建和管理流动性池，而每个交换合约则对应一个特定的交易对（例如 ETH/DAI）。

此外，UniswapV2 还引入了路由器合约和库函数，以提高交易效率和安全性。与其前身 UniswapV1 相比，UniswapV2 带来了几项重要改进。首先是闪电交换功能，允许用户在单个交易中借入资产，只要在交易结束前归还即可。其次是价格预言机，通过累积价格时间加权平均值（ TWAP ）来提供更可靠的价格数据。

此外，UniswapV2 支持任意 ERC-20 代币的直接交易，而无需通过以太坊作为中介。UniswapV2 的成功不仅在于其技术创新，还在于其开放性和社区驱动的开发模式。任何人都可以自由使用和扩展 Uniswap 协议，这为去中心化金融（ DeFi ）生态系统带来了无限的可能性。许多其他 DeFi 项目，如借贷平台和稳定币协议，都建立在 Uniswap 的基础之上，形成了一个繁荣的生态系统。

总的来说，UniswapV2 通过其创新的协议设计和去中心化的运营模式，彻底改变了加密货币交易的方式，成为 DeFi 领域的重要基石。随着技术的不断发展和社区的持续创新，UniswapV2 的影响力将进一步扩大，为全球用户带来更多的金融自由和机会。

![图片](univ2-img/640.2.webp)

![图片](univ2-img/640.3.webp)

Uniswapv1 会使用以太坊 (ETH) 作为过渡货币，即如果用户想进行 TokenA 和 TokenB 交换，需要先使用 TokenA 来换取 ETH ，之后再使用 ETH 来换取 TokenB ，尽管这种措施减少了流动性的分散，但它对流动性提供者造成了极大的成本压力。每个流动性提供者都必须具备与 ETH 交换的接口，同时，流动性提供者所持有资产的价值随着ETH的价格波动而波动，可能会导致严重的损失。

当两个资产 ABC 和 XYZ 相关联时（例如，它们都是美元稳定币），Uniswap 上的流动性提供者在 ABC / XYZ对中通常会承受较小的永久损失，相较于 ABC/ETH 或 XYZ/ETH 对。此外，使用 ETH 作为强制过渡货币会增加交易者的成本。交易者需要支付的费用是直接购买 ABC/XYZ 对费用的两倍，并且还会遭受两次滑点。

在 UniswapV2 当中，允许流动性提供者为任意两个 ERC-20 代币创建交易对合约。虽然任意 ERC-20 代币之间的交易对数量激增，可能会使找到特定资产交易路径变得更加复杂，但这一问题可以通过更高级别的路由来解决（通过链外或链上路由器或聚合器）。

![图片](univ2-img/640.4.png)

![图片](univ2-img/640.5.webp)

UniswapV1的价格计算方式是在 t 时刻，Uniswap 所提供的边际价格（不包含手续费）可以通过用资产 a 的储备量除以资产 b 的储备量来获得。具体的计算公式如下：

![图片](univ2-img/640.6.webp)

![图片](univ2-img/640.7.png)

然而，UniswapV1 用作链上价格预言机并不安全，因为它非常容易被操纵。操纵者会在一个区块的开头大量卖出某种资产 A 以影响价格，然后在该区块中间根据波动的价格执行其他合约操作（非 Uniswap 交易对合约），最后在区块结束时买回相同数量的资产 A，使价格恢复正常水平。Uniswap V2 引入了价格累计机制，允许第三方使用某一区间的平均价格，从而大大增加了价格操纵的难度，并使得操纵行为无实质收益。

具体来说，Uniswap v2 通过在每个区块开始时记录价格的累积和来累积这个价格，其中有人与合约交互。每个价格根据自上一个区块更新以来所经过的时间进行加权，根据区块时间戳。这意味着，在任何给定时间（更新后），累积器的值应该是合约历史中每一秒的现货价格的总和。

![图片](univ2-img/640.8.webp)

为了估算从时间 t₁  到 t₂ 的时间加权平均价格，外部调用者可以在 t₁ 检查累积器的值，然后在 t₂ 再次检查，减去第一个值，然后除以经过的秒数。（注意，合约本身不存储这个累积器的历史值——调用者必须在周期开始时调用合约以读取和存储这个值。）

![图片](univ2-img/640.9.webp)

预言机的用户可以选择何时开始和结束这个周期。选择一个更长的周期会使攻击者操纵时间加权平均价格（TWAP）的成本更高，尽管这会导致价格的最新程度较低。由于采用了平均值，A/B 和 B/A 在某一区间内的平均值不再是倒数关系，因此 Uniswap V2 提供了这两种价格。

![图片](univ2-img/640.10.png)

由于 Solidity 不支持非整数的数值数据类型，UniswapV2 采用 UQ112.112 数据格式来提升价格计算的精度，同时使用 uint112 来存储交易对中的资产数量，并用 32 位来记录当前区块的创建时间。这种时间记录方式在 100 年后，也就是 2106 年 2 月 7 日，会导致 Unix 时间戳溢出。这个是因为 Unix 时间戳是以自 1970 年 1 月 1 日（称为 Unix 纪元）以来经过的秒数来表示时间的，而 uint32 能表示的范围是从0到 2^{32} - 1 秒，即约 136 年。

为了确保系统在 2106 年 2 月 7 日及以后仍能正常工作，UniswapV2 的设计中要求预言机每隔一个溢出周期（约 136 年）至少检查一次价格。这是因为在这种设计下，即使时间戳溢出，累积价格的方法仍然是溢出安全的，即使交易跨越溢出间隔也可以正确计算价格变化。通过这种方法，确保系统在长时间内保持准确和可靠。

![图片](univ2-img/640.11.webp)

闪电兑换是一种在区块链平台上进行的即时加密货币交换，用户可以在无需等待多个区块确认的情况下快速完成不同加密货币之间的交易。这种交易通常由智能合约自动执行，确保交易双方同时履行交换承诺，从而降低交易风险并提高效率。简答来说，闪电兑换就是先欠再还进行交易，通过闪电兑换可以实现零成本套利。

我们通过一个实际例子来解释一下闪电兑换，假定 UniswapV2 中存在一个 A/B 的交易对，我们可以先借 A ，从而从 Uniswap 当中获取 B ，之后再使用 B 从其他的去中心化交易所上获取 A0，之后归还 Uniswap 等量的 A 即可。通过上面这个流程，我们就 0 成本的完成了 A0-A 之间的价差套利。我们并不需要任何本金，只需要支付 gas 费即可。如果发现链上其他的 dex 之间有价差，也可以对其进行类似的操作进行零成本的套利。

![图片](univ2-img/640.12.webp)

UniswapV2 引入了一个可以开启和关闭的 0.05% 协议费。如果开启，这个费用将发送到 factory 合约中指定的 feeTo 地址。最初，feeTo 是未设置的，因此不收取费用。一个预先指定的地址 feeToSetter 可以调用 UniswapV2 factory 合约中的 setFeeTo 函数，设置 feeTo 为不同的值。feeToSetter 还可以调用 setFeeToSetter 来更改 feeToSetter 地址本身。

如果设置了 feeTo 地址，协议将开始收取 5 个基点的费用，这是流动性提供者赚取的 30 个基点费用的 \\frac{1}{6} 。也就是说，交易者将继续支付 0.30% 的所有交易费用，其中 83.3%（即 0.25%）将支付给流动性提供者，16.6%（即 0.05%）将支付给 feeTo 地址。在每次交易时收取这 0.05% 的费用会增加额外的 gas 成本。为了避免这种情况，累计费用仅在存入或提取流动性时收取。合约会计算累计费用，并在代币铸造或销毁之前立即将新的流动性代币铸造给费用受益人。

累计费用可以通过测量√k 的增长来计算（即 √（x·y） ），自上次收取费用以来。这公式给出了在 t₁ 和 t₂ 之间，作为 t₂ 时流动池中流动性的百分比的累计费用：

![图片](univ2-img/640.13.webp)

如果费用在 t₁ 之前被激活，feeTo 地址应当捕获  t₁ 到 t₂ 之间累计费用到 ⅙。因此，我们想要铸造新的流动性代币到 feeTo 地址，代表 Φ·f₁,₂ 的池子， 其中Φ=⅙ 。

也就是说，我们希望选择 sₘ 来满足以下关系，其中 s₁ 是时间 t₁ 时的流通股的总量：

![图片](univ2-img/640.14.png)

经过一些运算，包括用 1- 

来代替 f₁,₂ 并求解 sₘ ， 我们可以将其改写为：

![图片](univ2-img/640.15.webp)

![图片](univ2-img/640.16.webp)

将 Φ 设置为 ⅙ ，我们会得到以下公式

![图片](univ2-img/640.17.webp)

下面，我们通过一个具体的例子来解释一下。假设初始存款人将 100 DAI 和 1 ETH 存入一个配对中，获得 10 股。一段时间后（没有其他存款人参与该配对），他们尝试提取资金，此时该配对中有 96 DAI 和 1.5 ETH。将这些值代入上述公式，我们得到如下结果：

![图片](univ2-img/640.18.webp)

![图片](univ2-img/640.19.webp)

UniswapV1 交易费用的计算是公式是

![图片](univ2-img/640.20.webp)

这个公式意味着只是先减少支付数量后再执行恒定乘积公式；在 UniswapV2 的版本中，因为 Flash Swaps 机制的存在，交易费用的计算公式调整为 

![图片](univ2-img/640.21.webp)

![图片](univ2-img/640.22.webp)

sync() 用于将合约中暂存的资产数量更新为合约的当前实际值，主要用于处理那些比例失衡且没有流动性提供者的情况。skim() 则用于处理合约内某种资产数量超过 uint112 最大值的情况，允许用户提取超出 uint112 最大值的那部分资产。

![图片](univ2-img/640.23.webp)

标准的 ERC20 代币合约在转移代币后需要返回一个布尔值来表示转移是否成功，但并非所有代币都会这么做。有些代币没有返回值。在 UniswapV1 中，对于没有返回值的代币转移默认视为失败，整个交易会被重置。而在 Uniswap V2 中，没有返回值的代币转移被视为成功。

此外，UniswapV1 假设代币转移不会触发交易对的重入，但支持 ERC777 hooks 的一些 ERC20 代币打破了这一假设。为了支持这些代币，UniswapV2 在所有公共状态变量修改函数中增加了防重入锁功能，同时也阻止了 Flash Swaps 中用户自定义回调的重入。

![图片](univ2-img/640.24.png)

如果用户为一个已经存在的交易对 A/B 提供流动性，那么根据当前 A 和 B 的比例就可以计算出来要提供多少比例的 A 和 B 。但是在一个交易对初始化的时候，没有可以参考的比例，拿这个时候应该怎么处理呢？在 UniswapV1 的版本中，当新的流动性提供者将代币存入现有的 Uniswap 代币对时，将根据现有代币数量计算所铸造的流动性代币数量。具体的计算公式如下:

![图片](univ2-img/640.25.webp)

对于第一个提供流动性的人来说，公式当中的是_Xstarting_是 0。在面对这种情况，UniswapV1 采用的方法是初始流动性的数值直接等于初始提供的 ETH 数量，这种初始流动性的提供的问题在于交易对的价值完全由初始流动性的比例所决定的，但是问题在于，没有任何机制去担保这个比例就是符合真实价值的。在 UniswapV2 当中，流动性的初始化可以用如下的公式

![图片](univ2-img/640.26.webp)

这个公式的意思是 _Sminted_ 这是你将获得的流动性代币的数量, _Xdeposited_ 这是你存入的第一种代币的数量.例如，如果你存入的是 ETH，那 _Xdeposited_ 就是你存入的 ETH 数量。 _Ydeposited_ 这是你存入的第二种代币的数量。

例如，如果你存入的是 DAI，那  _Ydeposited_ 就是你存入的 DAI 数量。这个公式可以保证流动资金池中的份额永远不会低于该池中的几何平均值，但是这个公式的值也会随着池子当中代币数量的变化而变化，为了减弱资金池中代币数量变化带来的影响，UniswapV2 销毁了最初的 1e- ¹⁵ 流动性，这个数值是最小流动性 1e-¹⁸ 的 1000 倍。尽管对于任何交易对来说这都微不足道，但却显著增加了利用这一机制获利的攻击者的成本。

![图片](univ2-img/640.27.webp)

由于交易以太坊原生货币 ETH 的接口与交易 ERC20 代币的接口不同，许多协议不直接支持 ETH，而是使用一种替代品 WETH（包装后的 ETH 代币）。UniswapV1 是个例外，因为它的交易对中直接包含了 ETH，允许用户直接使用 ETH 进行交易。然而，Uniswap V2 设计为支持任意 ERC20 代币之间的交易对，直接支持 ETH 会使系统复杂化且增加风险。

因此，UniswapV2 中不直接支持 ETH，用户在使用交易对前必须先将 ETH 转换成 WETH。实际上，UniswapV2 内部自动将用户提供的 ETH 转换为 WETH，这样简化了用户的操作，让他们无需手动转换 ETH 为 WETH。虽然对任何交易对来说这种转换是微不足道的，但它有效地提高了系统的安全性和操作简便性。

![图片](univ2-img/640.28.webp)

无论是 UniswapV1 还是 UniswapV2，所有交易对都是通过单一的工厂（factory）合约创建的。在 UniswapV1 中，使用的是 create 操作码，交易对合约的地址会受到创建顺序的影响。而在 UniswapV2 中，采用了新的操作码 create2 ，这种方法生成的地址是确定的。这意味着可以在链下提前计算出交易对的地址，而不需要查询链上的状态。

![图片](univ2-img/640.29.png)

为了高效地实现预言机功能，Uniswap V2 采用 uint112 来保存代币数量，这意味着其最大支持的代币数量为 2¹¹² - 1 。对于精度为 18 的代币来说，这个数值是足够的，大约为 5192296858534828（ 5.19e¹⁵）枚，即 5.19 千万亿枚。如果合约中的记录值超过了这个限制，交易将会失败并重置。正如之前提到的，任何人都可以使用 skim() 函数来恢复，通过移除流动性池中多余的资产来解决这一问题。

![图片](univ2-img/640.30.webp)

Uniswap 是一种自动化流动性协议，由恒定的产品公式提供支持，并在以太坊区块链上的不可升级智能合约系统中实现。它消除了对可信中介机构的需求，优先考虑去中心化、抗审查和安全性。每个 Uniswap 智能合约或货币对都管理着一个由两个 ERC-20 代币储备组成的流动性池。任何人都可以通过存入每个标的代币的等值值来换取池代币，从而成为资金池的流动性提供者 （LP）。这些代币跟踪总储备中按比例分配的 LP 份额，并且可以随时赎回标的资产。

首先先介绍 Uniswap 的自动做市商机制，下面展示了 UniswapV2 自动做市商（AMM）模型的函数图像，是基于如下公式的：

![图片](univ2-img/640.31.webp)

其中，_x_ 代表 Token A 的数量，_y_ 代表 Token B 的数量，_k_ 是一个常数，表示池中两种代币数量的乘积保持不变。交易者在 Uniswap 上进行交易时，通过向池中添加或移除代币，改变了池中代币的数量。根据恒定乘积公式，另一种代币的数量会相应变化，以保持乘积 _k_ 不变。这种变化决定了交易的价格。

例如，如果交易者希望用 Token A 交换 Token B，他们需要向池中增加一定数量的 Token A，这会导致池中的 Token B 数量减少，从而改变价格。交易者的操作会沿着这条曲线移动，改变代币的数量和价格。曲线上任意一点都满足恒定乘积关系。

![图片](univ2-img/640.32.webp)

UniswapV2 的工作原理大概可以分成三个部分，流动性提供者（ Liquidity Provider），Uniswap 池（Uniswap Pool），交易者（Trader）。流动性提供者的作用是流动性提供者将两种代币（例如，Token A 和 Token B）存入 Uniswap 池中。

图中显示的例子中，流动性提供者存入了 10 个 Token A 和 1 个 Token B；Uniswap 池中储备了各种代币，例如图中显示的 100 个 Token A 和 10 个 Token B。

池中的流动性份额由流动性代币表示，图中显示共有 12 个流动性代币；交易者交易者可以向池中提交代币并交换他们需要的另一种代币。例如，交易者可以存入 10 个 Token A，并支付 0.3% 的手续费，从池中获取 1 个 Token B。

![图片](univ2-img/640.33.webp)

我们先看流动性提供者 (LP) 是如何提供流通性的。如下图所示，流动性提供者将代币存入 Uniswap 池中，增加流动性。

例如，在图中，流动性提供者存入了 3 个 Token A 和 1 个 Token B 。当流动性提供者存入代币后，他们会收到代表其流动性份额的池代币（ Pool Tokens ）。在图中，流动性提供者获得了 12.4 个池代币。池中的代币储备会增加，例如，图中池中的代币储备变为 1210 个 Token A 和 399 个 Token B 。更多的流动性有助于降低价格滑点，使交易更加稳定。 

Uniswap 使用的恒定乘积公式 _x · y = k_ 来确定价格曲线。增加的流动性扩展了低滑点区域，提升了交易的价格稳定性。流动性提供者通过存入代币来增加池中的流动性，并获得相应的流动性代币作为回报。这不仅帮助了交易者获得更稳定的价格，也为流动性提供者带来了交易手续费的收益。

![图片](univ2-img/640.34.png)

接下来，我们从交易者的视角去看，交易者是如何换取代币以及交易行为会对 Uniswap Pool 产生什么影响。

如下图所示，交易者希望在 Uniswap 上交换代币。例如，在图中，交易者打算交换3个 Token A 。交易者输入 3 个 Token A ，并支付 0.3% 的手续费。最终，交易者将获得约 0.997 个 Token B 作为输出。交易会改变池中的储备平衡，从而导致新的价格。在交易前，池中有 1200 个 Token A 和 400 个 Token B 。

根据恒定乘积公式 _x·y = k_ 交易后的池中将有大约 1203.009 个 Token A 和大约 399.003 个 Token B 。Uniswap 使用 _x·y = k_ 的恒定乘积公式来定义价格曲线。随着交易者的交换操作，池中的代币数量变化，价格曲线也随之调整，确定新的价格。

![图片](univ2-img/640.35.webp)

![图片](univ2-img/640.36.webp)

![图片](univ2-img/640.37.webp)

![图片](univ2-img/640.38.png)

在这一节，我们会介绍在 UniswapV2 当中最常用的三个操作，即添加流动性，撤除流动性，交换代币。我们会通过流程图来分析他们调用的合约以及调用的函数，来更加深刻的理解 UniswapV2 的源码。

![图片](univ2-img/640.39.webp)

用户在添加流动性的时候，用户首先调用 UniswapV2Router.sol 合约，提供 Token A 和 Token B 的数量，UniswapV2Router.sol 合约的 addLiquidity 函数接收用户的请求并进行处理。

addLiquidity 函数进一步调用 UniswapV2Pair.sol 合约，在 UniswapV2Pair.sol 合约中，调用 mint 函数执行实际的流动性添加操作，mint 函数根据用户提供的 Token A 和 Token B 的数量，计算应铸造的流动性代币（LP 代币）的数量，并将这些 LP 代币分配给用户，流动性添加操作完成后，mint 函数调用 \_update 函数更新储备量。

![图片](univ2-img/640.40.webp)

![图片](univ2-img/640.41.webp)

用户想要交换代币的时候，首先调用 UniswapV2Router.sol 合约，提供输入代币数量和最小输出代币数量。

然后 UniswapV2Router 合约的 swapExactTokensForTokens 函数接收用户的请求并进行处理，swapExactTokensForTokens 函数进一步调用 UniswapV2Pair.sol 合约，在 UniswapV2Pair.sol 合约中，调用 swap 函数执行实际的代币交换， swap 函数根据输入代币数量和储备量，计算应输出的代币数量，并执行交换，交换完成后，swap 函数调用 \_update 函数更新储备量和累计手续费。具体的流程如下所示：

![图片](univ2-img/640.42.webp)

![图片](univ2-img/640.43.png)

用户首先调用 UniswapV2Router.sol 合约，提供要撤出 LP 代币的数量，UniswapV2Router.sol 合约的 removeLiquidity 函数接收用户的请求并进行处理，removeLiquidity 函数进一步调用 UniswapV2Pair.sol 合约，在 UniswapV2Pair.sol 合约中，调用 burn 函数执行实际的流动性撤出操作，burn 函数根据提供的 LP 代币数量，计算应返还的 Token A 和 Token B 数量，并将这些代币返还给用户。

![图片](univ2-img/640.44.png)

![图片](univ2-img/640.45.webp)

UniswapV2 Core 合约是去中心化交易平台 Uniswap 的核心部分，负责实现其自动化做市商（ AMM ）功能。与传统订单簿不同，Uniswap 通过流动性池和恒定乘积公式 _x·y = k_ 来实现交易。流动性提供者将两种代币存入池中，获得流动性代币作为凭证。用户在进行交易时，合约根据池中代币数量和恒定乘积公式计算交易价格。UniswapV2 引入了多项改进，包括 ERC20 pairs 直接交易，价格预言机的改进， 闪电贷以及协议费的调整。core 合约当中的核心组件包括下面三个文件：

-   UniswapV2Pair.sol ：管理每个交易对的流动性池，处理代币交换、流动性添加和移除
    
-   UniswapV2Factory.sol ：负责创建和管理交易对
    
-   UniswapV2ERC20.sol ：流动性代币的标准实现，代表流动性提供者的份额
    

![图片](univ2-img/640.46.webp)

![图片](univ2-img/640.47.webp)

UniswapV2Factory 合约的作用是负责创建和管理交易对（流动性池）。该合约允许用户创建新的交易对，并记录所有创建的交易对。此外，它还管理交易费接收地址和设置者地址。UniswapV2Factory.sol 有五个函数，分别来看一下

-   constructor 函数：构造函数，用于初始化 UniswapV2Factory 合约。输入是交易费设置者地址 \_feeToSetter ， 输出是无。
    
-   allPairsLength 函数：返回所有创建的交易对的数量。 输入是无， 输出是所有交易对数量的 unit。
    
-   createPair 函数： 创建新的交易对。输入是 tokenA 和 tokenB 的两个代币地址，输出是创建的交易对地址 pair。
    
-   setFeeTo 函数： 设置交易费接受地址。 输入是新的交易费接受地址 \_feeTo， 输出是无。
    
-   setFeeToSetter 函数： 设置新的交易费设置者地址。输入是新的交易费设置者地址 \_feeToSetter， 输出是无。
    

具体的代码解析如下：

![图片](univ2-img/640.48.webp)

![图片](univ2-img/640.49.webp)

![图片](univ2-img/640.50.webp)

![图片](univ2-img/640.51.webp)

**createPair 函数**

createPair 函数的作用是创建一个以 TokenA 和 TokenB 的交易对，在前端输入 TokenA 和 TokenB 之后，会先检查 TokenA 和 TokenB 是否是同一个币种，之后会对 TokenA 和 TokenB 做一个简单的排序，之后是检查 Token0 的地址，要求 Token0 的地址不能是 0；

之后是通过 require(getPair\[token0\]\[token1\] == address(0), 'UniswapV2: PAIR\_EXISTS') ; 来检查这个代币对是否存在，只有存在了，才可以进行下去；后面通过 creationCode 来获取 UniswapV2Pair 合约的创建字节码；

之后使用 token0 和 token1 的哈希值作为盐值，确保每个代币对的地址是唯一的，因为如果代币对的地址不唯一，那么交易者添加流动性可能会添加到错误的池子当中；之后使用内联汇编的 create2 指令创建合约，保证合约地址的唯一性和可预测性；

之后便是初始化新创建的代币对合约，然后更新映射表，记录这个代币对合约的地址，然后将新创建的代币对合约地址添加到所有代币对的列表中，最后是触发 PairCreated 事件，通知外部有新的代币对创建

![图片](univ2-img/640.52.webp)

![图片](univ2-img/640.53.webp)

![图片](univ2-img/640.54.webp)

![图片](univ2-img/640.55.png)

UniswapV2ERC20.sol 的主要功能是实现 ERC-20 代币，它实现了 ERC20 标准的代币功能，专门用于 UniswapV2 流动性池。合约包含铸造（ mint ）、销毁（ burn ）、批准（ approve ）和转移（ transfer ）等基本操作。此外，它还支持 permit 功能，允许使用签名来批准代币转移。我们来逐个看他包含的函数：

-   constructor 函数：初始化合约，设置 DOMAIN\_SEPARATOR 用于 permit 功能。输入无，输出无。
    
-   \_mint 函数：铸造新的代币，输入是接收地址“ to ”，和铸造数量“ value ”，输出无
    
-   \_burn 函数： 销毁代币，输入是销毁地址 from 和销毁数量 value，输出无。
    
-   \_approve 函数： 批准代币转移，所有者地址 owner，批准地址 spender 和批准数量 value，输出无。
    
-   \_transfer 函数：转移代币， 输入是转出地址 from，接收地址 to 和转移数量 value， 输出无。
    
-   approve 函数：公开的批准函数，作用是调用 \_approve 函数，输入是approve 函数公开的批准函数， 输出是返回布尔值 true 表示操作成功。
    
-   transfer 函数：作用是调用 \_transfer 函数，输入是接受地址 to 和转移数量 value， 输出是返回布尔值 true 表示操作成功
    
-   transferFrom 函数：公开的授权转移函数。输入是转出地址 from，接收地址 to 和 转移数量 value，输出是 返回布尔值 true 表示操作成功
    
-   permit 函数： 使用签名来批准代币转移，验证签名并调用 \_approve 函数，输入是所有者地址 owner，批准地址 spender，批准数量 value，截止时间 deadline，签名参数 v、r、s，输出无。
    

官方的源码解析如下所示：

![图片](univ2-img/640.56.webp)

![图片](univ2-img/640.57.webp)

![图片](univ2-img/640.58.webp)

![图片](univ2-img/640.59.webp)

![图片](univ2-img/640.60.webp)

![图片](univ2-img/640.61.webp)

UniswapV2Pair 即交易对合约，实现了 Uniswap v2 的核心功能，即管理和操作每个交易对的流动性池。该合约负责处理代币的交换、流动性的添加和移除，以及价格的累积计算。它确保在每次交易后，交易对的储备和价格信息得到更新，并触发相应的事件通知。UniswapV2Pair.sol 中有 11 个函数，具体入下面表格所示：

![图片](univ2-img/640.62.webp)

官方的 UniswapV2Pair.sol 的代码和注释如下：

![图片](univ2-img/640.63.webp)

![图片](univ2-img/640.64.webp)

![图片](univ2-img/640.65.webp)

![图片](univ2-img/640.66.webp)

![图片](univ2-img/640.67.webp)

![图片](univ2-img/640.68.webp)

![图片](univ2-img/640.69.png)

![图片](univ2-img/640.70.webp)

![图片](univ2-img/640.71.webp)

![图片](univ2-img/640.72.webp)

![图片](univ2-img/640.73.png)

![图片](univ2-img/640.74.webp)

UniswapV2Pair 是继承 IUniswapV2Pair, UniswapV2ERC20，首先看看 IUniswapV2Pair 的源码，看看 IUniswapV2Pair 如何定义接口：

![图片](univ2-img/640.75.webp)

![图片](univ2-img/640.76.png)

![图片](univ2-img/640.77.webp)

![图片](univ2-img/640.78.webp)

之后定义了全局变量和修饰器

![图片](univ2-img/640.79.webp)

![图片](univ2-img/640.80.webp)

上面的 MINIMUM\_LIQUIDITY 是一个常量，它设定了流动性池中必须保留的最小流动性代币数量，以确保流动性提供者在任何时候都至少保留一定量的代币，从而避免流动性枯竭，数值是 10 的3次方，在提供初始流动性时会被燃烧掉； SELECTOR 存储的是代币转账函数的 ABI（应用程序二进制接口）选择器，它用于在智能合约中准确地识别和调用其他合约的 transfer 函数，确保在执行代币转移时使用正确的函数签名；

factory 用于存储交易对合约的Uniswap V2工厂合约的地址，Token0，Token1 用于存储代币地址，reserve0, reserve1 和 blockTimestampLast 这三个状态变量记录了最新的恒定乘积中两种资产的数量和交易时的区块(创建)时间；

而 price0CumulativeLast 和 price1CumulativeLast 变量用于记录交易对中两种价格的累计值，kLast 用于跟踪 UniswapV2 交易对中两种代币储备量乘积的最近状态，作为一个关键参数来维持流动性池的价格稳定性和计算交易费用，主要用于团队手续费的计算。

下面这一段修饰器是提供了一种锁机制来防止重入攻击，具体代码解析如下：

![图片](univ2-img/640.81.webp)

上面的代码当中的 \_; 表示被修饰的函数体，这段代码的大致逻辑是：定义了一个 lock 修饰符，它通过改变 unlocked 变量的状态来确保在执行被修饰的函数期间合约不会被重新进入，从而防止重入攻击和竞态条件。

下面的 getReserves 函数的作用是提供一种方式来公开查询并返回 UniswapV2 交易对合约当前的两种代币储备量和最后更新时间戳的信息。

![图片](univ2-img/640.82.webp)

![图片](univ2-img/640.83.webp)

\_safeTransfer 函数的作用是在智能合约内部执行代币的转移操作，并检查转移是否成功，如果失败则抛出异常，确保了合约的安全性和代币转移的可靠性，下面是这一段代码的详细注释：

![图片](univ2-img/640.84.webp)

下面的构造函数只是简单的用于初始化 factory：

![图片](univ2-img/640.85.webp)

initialize 函数的作用是设置交易对合约所涉及的两种代币的地址，且只能由部署交易对的工厂合约(factory) 来调用，确保交易对的初始化过程是安全和受控的。

![图片](univ2-img/640.86.webp)

\_update 函数的主要作用是确保交易对合约的储备量和价格累积器能够反映最新的状态， 具体实现的方法是通过比较当前区块的时间戳和上次更新的时间戳。\_update 函数的四个输入参数分别是：balance0 和 balance1 ，表示交易对中两种代币当前的余额；\_reserve0 和 \_reserve1 ，表示函数调用前两种代币的储备量。我们接下来用bullet point的方式来讲解一下 \_update 函数是如何实现的：

1.  检查余额值是否可能导致溢出：通过 require语句确保传入的 balance0 和 balance1 不会超过 uint112 的最大值，这是因为 reserve0 和 reserve1 在存储时使用 uint112 类型，需要保证数据类型转换的安全性。
    
2.  记录当前区块时间：获取当前区块的时间戳，并将其与 blockTimestampLast 进行模2^32运算，得到 blockTimestamp 。这个操作是因为以太坊的区块时间戳是32位的，而且我们只关心在一个区块内的时间差，而不是绝对时间。
    
3.  计算时间差：计算当前区块时间与上次更新时间的差值 timeElapsed 。如果 timeElapsed 为0，表示这是同一区块内的连续调用，因此不会更新价格累积值。
    
4.  价格累积更新：如果时间差大于0，并且储备量不为0，使用固定点数学库 UQ112x112 来计算价格比例，并更新 price0CumulativeLast 和 price1CumulativeLast 。这里的“never overflows”意味着由于时间间隔 timeElapsed 是 uint32 类型，与价格累积值（uint224）相乘不会导致溢出。“+ overflow is desired”指的是价格累积值允许溢出，因为价格计算使用的是变化量（delta）而不是绝对值，即使有溢出，计算平均价格时使用的变化量仍然是准确的。
    
5.  更新储备量：将新的余额赋值给 reserve0 和 reserve1 ，更新流动性池的储备量。
    
6.  更新时间戳：将当前区块时间戳赋值给 blockTimestampLast ，为下一次更新做准备。
    
7.  触发同步事件：通过 emit 关键字发出 Sync 事件，告知外部监听者储备量已经更新。
    

这种设计允许 UniswapV2 在处理大量交易时保持价格的连续性和准确性，即使在区块时间戳或价格累积值可能溢出的情况下，依然能够通过变化量来准确计算出平均交易价格。这是通过巧妙地利用固定点数学和时间差分来实现的。

![图片](univ2-img/640.87.webp)

![图片](univ2-img/640.88.webp)

在 UniswapV2 中，用户每笔交易会被收取0.3%的手续费。这笔手续费中的六分之一将分配给开发团队，而剩下的六分之五将作为奖励给予流动性提供者。然而，如果每次交易都计算一次手续费，这将不可避免地增加用户的 Gas 费用。

因此，在UniswapV2中，手续费会被累积起来，只有在流动性发生变化时才会对手续费进行分配。\_mintFee函数首先检查是否开启了交易费用，并确定费用接收地址。如果交易费用未开启，且之前有铸造过费用(\_kLast不为0)，则重置 kLast 值。这种费用铸造机制是 UniswapV2 的一部分，用于为流动性提供者提供额外的激励；如果交易费用开启，则根据下面的公式来计算手续费的值，

![图片](univ2-img/640.89.webp)

Sₘ 表示应该铸造的手续费流动性代币数量，k₁表示上一个流动性事件后的储备的乘积k，k₂ 表示当前的储备乘积k，S₁表示上一个流动性事件后的总流动性代币供应量。

![图片](univ2-img/640.90.webp)

![图片](univ2-img/640.91.webp)
